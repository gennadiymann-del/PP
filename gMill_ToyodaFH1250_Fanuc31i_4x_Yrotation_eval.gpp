; General Post Processor
; Machine           :
; Type              :
; SubRoutines       :
; Comp Type         : 
; Customer          : 
; Rev 1.0 :10.23.2012 : Configured post for evaluation version software.
; ---Things to do-----
;

@init_post

    global string sUS_date sUS_time sUsrmsg sHomestr sHomestrbegin sHomestrtc sHomestrend sHomestrstpdiff sHomestrstpsame sHomeline sHomestrendsub
    global string sCamfilepath sSubspath cWo cPb cPe cG84 cG84p cCycs cHomep cTCcodep cTCcodes fG84spin cDr cCb cCe
    global logical bStartFile bTlchg bTraceUsrcall bUsrcall bSkipxyrapid bWorkoffsettc
    global logical bSubs bTlseperation bTcseperation bDateTimeOutput bStopM00difftool bToolPreselect bToolChangeAtEnd
    global logical bFromendprogram bFrombeginchangetool bFromendchangetool bFromendoffile bMultiplefixtures
    global logical bSafetyprep bSyncdrapid bFeedoutput bNnumtc
    global logical bOptstpbegin bOptstptc bOptstpend bUseprognum bUseprogname bCoolspinaftertc
    global logical bCoolExist bCoolofftc bSpinofftc bCooloffend bSpinoffend bG84spin bPrintloop bTest
    global integer iMplane iAbsincmode iWorkoffset iHeightcomp iStopmode iMotionmode iDefault_Coolant_Code
    global integer iDiametercomp iDrillmode iTcnumber iCoolantM iNumpecks iPworkoffset iSpindleDir
    global integer iSlength_g_file_name iSlength_full_g_file_name iSlengthcampartpath iDiameteroffset iArcmode
    global integer iHomingmode iWorkOffsetmode iProgendmode ihome_number iLhome_number
    global integer iCoolantM1 iCoolantM2 iCoolantM3 iCoolantM4 iCoolantM5 iCoolantM6 iCoolantM7 iCoolantM8
    global integer iCoolantM1ON iCoolantM2ON iCoolantM3ON iCoolantM4ON iCoolantM5ON iCoolantM6ON iCoolantM7ON iCoolantM8ON
    global integer iCoolantM1OFF iCoolantM2OFF iCoolantM3OFF iCoolantM4OFF iCoolantM5OFF iCoolantM6OFF iCoolantM7OFF iCoolantM8OFF
    global numeric nTcXnext nTcYnext nTcZnext nTcCnext nCorrectedpeck nRapidfeed

    global numeric  nR1pos nR1postmatrix nR1postransform nR1poscpos iR1dir nPtool_z_level nPR1pos nR1posadj nR1postemp
    global numeric nR1pos5x nPtool_start_plane prevFeed nLlabel
    global string cR1 sHomestrrot nR1pos_f bpos_f main_prog_path sTnums ;apos_f
    global integer iFeedType iR1posControl i4xIndexMode i4xIndexClearanceMode i4xFeedMode
    ; Non GPPL variables
    num_user_procs =    1
    remove_blanks = FALSE
    line_labels    = FALSE     ; Jump to N...
    clear_change_after_gen = 1

    ; GPPL variables
    numeric_def_f   = '5.4'
    integer_def_f   = '5.0(p)'
    gcode_f         = '2.0(p)'
    mcode_f         = '2.0(p)'
    xpos_f          = '5.4'
    ypos_f          = '5.4'
    zpos_f          = '5.4'
    nR1pos_f        = '5.3'
    apos_f          = '5.3'
    bpos_f          = '5.3'
    feed_f          = '4.4'
    blknum_f        = '5.0(p)'
    blknum_gen      = true
    bUsrcall = true
    call @usr_ip_useroptions
    bUsrcall = true
    call @usr_ip_postwriteroptions
endp

@usr_ip_useroptions
    ; Handle setting of options -- For users
    if bTraceUsrcall
        if bUsrcall
            {nl,'>>>>UserCalled @usr_ip_postwriteroptions<<<<<    '}
            bUsrcall = false
        endif
    endif
    ;Machine Definition
    bToolPreselect        = true      ;True = Next tool is Preselected after tool change
    bSyncdrapid           = true      ;True = Machine Sync's Rapid Motion (Non-Box Move)
    nRapidfeed            = 650.       ;Set your value for Max Feed in G1 (Used with Non-Sync'd Rapid Moves)
    bUseprognum           = true       ;True = Outputs Program Number
    bUseprogname          = true       ;True = Outputs Program Name
    iArcmode              = 4          ;Sets Arc Output Mode (1=AbsIJK, 2=IncIJK, 3=R 360AbsIJK, 4=R 360IncIJK)
    cTCcodep              = ''     ;Sets the Prefix Code(s) used for Tool Change (i.e. 'M06')
    cTCcodes              = 'M06 '     ;Sets the Suffix Code(s) used for Tool Change (i.e. 'M06')
    cWo                   = 'G'        ;Sets the Character(s) used for Work Offset (i.e. G,E,G54.1 P)
    iWorkOffsetmode       = 1          ;Sets the Mode used for Work Offset (1=G54, 2=E1, 3=G54.1 P1)
    iProgendmode          = 1          ;Sets the code for ending a program (1=M30,2=M2)
    cPb                   = '%'        ;Sets the Character(s) used for the beginning of file (i.e %)
    cPe                   = '%'        ;Sets the Character(s) used for the beginning of file (i.e %)
    cCb                   = '('        ;Sets the begginning Character(s) for comments
    cCe                   = ')'        ;Sets the ending Character(s) for comments
    cDr                   = 'G98 '     ;Sets the Character(s) used at the begging of a drill cycle (i.e. G98,G98,or nothing '')
    cG84                  = 'G84'      ;Sets the Drill Cycle Character(s) used tapping (i.e. G84, G84.1)
    cG84p                 = ''         ;Sets the Preperation Line used for G84 Tapping (i.e. G84.2)**FADAL setting
    bG84spin              = false      ;True = RPM is output during G84 Tapping Cycles
    fG84spin              = '5.1'      ;Sets Formatting for RPM used for G84 Tapping Cycles ('5.1' = Decimal point 1 place)
    cCycs                 = 'L0 '      ;Sets the Suppression Code to ignore Drill Cycles (i.e. LO)

    ;Coolant & Spindle Control
    iDefault_Coolant_Code = 8          ;Set your default Coolant type Coolant/Air/None (8=M8, 9=M9, 7=M7, etc)
    bCoolExist            = true       ;True = Outputs Coolant codes (Coolant,Air,Mist,etc)
    bCoolofftc            = true       ;True = Outputs Coolant off between Tool Changes
    bSpinofftc            = true       ;True = Outputs Spindle off between Tool Changes
    bCooloffend           = true       ;True = Outputs Coolant off at end of program
    bSpinoffend           = true       ;True = Outputs Spindle off at end of program
    bCoolspinaftertc      = false      ;True = Outputs Coolant&Spindle directly after Tool Change
    iCoolantM1ON          = 8           ;Code: Flood Coolant ON
    iCoolantM1OFF         = 9           ;Code: Flood Coolant OFF
    iCoolantM2ON          = 52          ;Code: Mist Coolant ON
    iCoolantM2OFF         = 9           ;Code: Mist Coolant OFF
    iCoolantM3ON          = 130         ;Code: HP-Flood Coolant ON
    iCoolantM3OFF         = 9           ;Code: HP-Flood Coolant OFF
    iCoolantM4ON          = 8           ;Code: LP-Flood Coolant ON
    iCoolantM4OFF         = 9           ;Code: LP-Flood Coolant OFF
    iCoolantM5ON          = 12          ;Code: High Pressure Coolant Through Tool ON
    iCoolantM5OFF         = 9           ;Code: High Pressure Coolant Through Tool OFF
    iCoolantM6ON          = 12          ;Code: Low Pressure Coolant Through Tool ON
    iCoolantM6OFF         = 9           ;Code: Low Pressure Coolant Through Tool OFF
    iCoolantM7ON          = 50          ;Code: Air Blast ON
    iCoolantM7OFF         = 9           ;Code: Air Blast OFF
    iCoolantM8ON          = 53          ;Code: Air through spindle ON
    iCoolantM8OFF         = 9           ;Code: Air through spindle OFF

    ;User Preferences
    bTlseperation         = true       ;True = Seperates Tool List by blank line(s)
    bTcseperation         = false       ;True = Seperates Tool Change by blank line(s)
    bDateTimeOutput       = true       ;True = Outputs Date & Time
    bToolChangeAtEnd      = false        ;True = Tool Change for First Tool at end of program
    bOptstpbegin          = false       ;True = Outputs Optional Stop at beginning of program   !@#$%AC 0.5
    bOptstptc             = true        ;True = Outputs Optional Stop between Tool Changes
    bOptstpend            = false       ;True = Outputs Optional Stop at end of program
    bWorkoffsettc         = true        ;True = Forces output of Work Offset at each Tool Change
    bNnumtc               = true        ;True = Outputs N Numbers at Tool Changes (i.e. N1,N2,N3)
    blknum_exist          = false       ;True = Outputs Line Numbers
    blknum                = 100         ;Sets Starting Line Number
    blknum_delta          = 1           ;Sets the delta for Line Numbers
    blknum_max            = 3200000     ;Sets the maximum value for Line Numbers

    ;Homing Format Definitions
    ;[integer:][Prepstr :][AxisStr1 ;][AxisStrN]
    ;integer = Homing Output Mode (1=G28, 2=G28 G91, 3=G53 Non-Modal, 4=G53 Modal, 5=G30, 6=G30 G91 7=G90 G54)
    ;PrepStr = Sets the code(s) for the begging of line used for Homing Axis (i.e. 'G00')
    ;AxisStr = Homing Axis Definition (i.e. 'Z0.0', 'H0.0 W0.')
    ;Note: You can define up to 49 "Homing Lines" seperated by ";"
    ;Note: Only use ";" if using more then 1 "Homing Line"
    ;Note: Define string as empty '' to ignore Specific Homing Definition
    sHomestrbegin         = ''	; Program Begin Homing Definition
    sHomestrtc            = '2:G00 :Z0.0 '	; Tool Change Homing Definition
    sHomestrend           = '2:G00 :Z0.0 ;2:G00 :B0.0 ;2:G00 :X0.0 P1 '	; Program End Homing Definition
    sHomestrendsub        = '2:G00 :Z0.0 '     ; Program End Homing Definition
    sHomestrstpsame       = '2:G00 :Z0.0 '	; M00 Same Tool Homing Definition
    sHomestrstpdiff       = '2:G00 :Z0.0 '	; M00 Different Tool Homing Definition
    sHomestrrot           = 'G00'	;Between Rotations

    ; ---- 4x
    iR1dir                = -1         ;1=+CCW -1=+CW
    cR1                   = 'B'       ;Rotary 1 Axis
    iR1posControl         = 0         ;Rotary Position Control (0=SolidCAM Direct, 1=Positive, 2=Negative, 3=Shortest Distance)
    i4xIndexMode          = 1         ;4x-Indexing control (0=Simple Rotation, 1=New WorkOffset, 2=Trig Macro)
    i4xIndexClearanceMode = 0         ;4x-Index Clearance control (0=Z-Homing, 1=Z-Tool_Z_Level, 2=Z-Tool_start_plane)
    i4xFeedMode           = 1         ;4x-Simultanious control (0=Programed feedRate, 1=Inverse Time FeedRate, 2=Deg. per Minute)
    ; ---- 4x
endp

@usr_ip_postwriteroptions
    ; Handle setting of options -- For Post Writers
    bSubs = false          ;True = Using sub routines, False = Not using sub routines
    ; ------Below are tracing functions-----
    ; trace "all":5
    ; trace "@change_tool":5
    ; trace "@def_tool":5
    ; trace "@tmatrix":5
    ; bTraceUsrcall = True  ;Trace UserCalls to procedures
endp

;-------------------

@start_of_file
    ; Handle what is output at the start of the file
    ; This is the first procedure called (lie...@init_post is actually first)
;    sCamfilepath = tostr(program_number)
;    {nl,'!!open file=' 'O' + sCamfilepath'!!'}
;    {nl}
    if iNumber_of_Fixtures > 1
        bMultiplefixtures = true
        blknum_exist    = false
    endif
    call @usr_campart_path
    call @usr_init_gmstates
    call @usr_sof_character
    call @usr_sof_progname
    call @usr_sof_commentsbeforecodes
    call @usr_sof_gmcodes
    call @usr_sof_commentsaftercodes

    {nl,cCb'MACHINE; TOYODA FH1250'cCe}
    if PartNumber ne ''
        {NL,'(PART NUMBER; ',PartNumber,')'}
    endif
    if Revision ne ''
        {NL,'(REVISION; ',Revision,')'}
    endif
    if message1 ne ''
        {nl}
        {nl,'(NOTES;)'}
        {nl}
        {NL,'(',message1,')'}
    endif
    if message2 ne ''
        {NL,'(',message2,')'}
    endif
    if message3 ne ''
        {NL,'(',message3,')'}
    endif
    if message4 ne ''
        {NL,'(',message4,')'}
    endif
    if message5 ne ''
        {NL,'(',message5,')'}
    endif
    if message6 ne ''
        {NL,'(',message6,')'}
    endif
    if message7 ne ''
        {NL,'(',message7,')'}
    endif
    if message8 ne ''
        {NL,'(',message8,')'}
    endif
    if message9 ne ''
        {NL,'(',message9,')'}
    endif
    if message10 ne ''
        {NL,'(',message10,')'}
    endif
    {nl}
    bStartFile = true
    iLhome_number = home_number
endp

@usr_sof_character
    ; Handle start of file character
    if cPb ne ''
        {cPb}
    endif
endp

@usr_sof_progname
    ; Handle Program Number and/or Name
    if bUseprognum
        {nl, 'O'(program_number)}
        if bUseprogname
            {' 'cCb,PartNumber,' ; REV ',Revision,' ; FH1250'cCe}
        endif
    else
        if bUseprogname
            {nl, cCb, part_name,cCe}
        endif
    endif
endp

@usr_sof_commentsbeforecodes
    ; Handle HardCoded or PartControlled comments ~Before gmcodes~
    {nl}
    call @usr_US_date
    call @usr_US_time
    if bDateTimeOutput
        {nb,cCb,'PROGRAMMED; 'sUS_date'-'sUS_time,cCe}
    endif
endp

@usr_sof_gmcodes
    ; Handle HardCoded or PartControlled G/M codes
endp

@usr_sof_commentsaftercodes
    ; Handle HardCoded or UserDefined comments (After G/M codes)
endp

@usr_US_date
    ; Converts Europe Date format to US format
    Local Integer iInt1
    iInt1 = instr(date,'-')
    sUS_date = substr(date,(iInt1+1),3) + '-' + substr(date,1,(iInt1-1)) + '-' + right(date,4)
endp

@usr_US_time
    ; Converts Military time to 12hr format
    Local Integer iInt1 iHr_Mil_int iHour
    Local String iHr_Mil iTm_of_day
    iInt1 = instr(time,':')
    iHr_Mil = left(time,(iInt1-1))
    iHr_Mil_int = tonum(iHr_Mil)
    if iHr_Mil_int < 12
        if iHr_Mil_int < 1
            iHour = 12
        else
            iHour = iHr_Mil_int
        endif
        iTm_of_day = 'AM'
    else
        if iHr_Mil_int < 13
            iHour = 12
        else
            iHour = iHr_Mil_int - 12
        endif
        iTm_of_day = 'PM'
    endif
    sUS_time = tostr(iHour:'5.0(p)') + substr(time,iInt1,8) + iTm_of_day
endp

@usr_init_gmstates
    ; Handle initializing gmcodes for correct modality from beginning of file
    iMplane         = 9999
    iAbsincmode     = 9999
    iWorkoffset     = 9999
    iHeightcomp     = 9999
    iMotionmode     = 9999
    iDiametercomp   = 9999
    iDiameteroffset = 9999
    iDrillmode      = 9999
    iTcnumber       = 0
    iCoolantM1      = iCoolantM1OFF
    iCoolantM2      = iCoolantM2OFF
    iCoolantM3      = iCoolantM3OFF
    iCoolantM4      = iCoolantM4OFF
    iCoolantM5      = iCoolantM5OFF
    iCoolantM6      = iCoolantM6OFF
    iCoolantM7      = iCoolantM7OFF
    iCoolantM8      = iCoolantM8OFF
    ; ---- 4x
    nR1pos          = 9999
    iFeedType       = 94
    ; ---- 4x
endp

;-------------------

@def_tool
    ; Handle Tool List Output at top of progam
    ; Use bTlchg to use different message for tool_change
    if tool_message == '' then
        {nb, cCb'TOOL 'tool_number, '   DIA '(tool_offset*2),cCe }
    else
        {nb,cCb'T'tool_number,' ' tool_message,cCe}
        if msg_mill_tool1 ne ''
            {nb,cCb'---' msg_mill_tool1,cCe}
        endif
        if msg_mill_tool2 ne ''
            {nb,cCb'---' msg_mill_tool2,cCe}
        endif
        if msg_mill_tool3 ne ''
            {nb,cCb'---' msg_mill_tool3,cCe}
        endif
        if msg_mill_tool4 ne ''
            {nb,cCb'---' msg_mill_tool4,cCe}
        endif
        if msg_mill_tool5 ne ''
            {nb,cCb'---' msg_mill_tool5,cCe}
        endif
    endif
    if next_command ne '@def_tool' and bTlchg eq false
        if bTlseperation
            {nl}
        endif
        if bOptstpbegin
            call @usr_optionalstop
        endif

    endif
endp

;-------------------

@start_program
    ; Handle any safety gmcodes for top of program
;	{nb}
;	call @usr_abs_inc_output
;	call @usr_mp_output
;	side = COMP_OFF
;	call @compensation
;	call @usr_compensation_output
;	skipline = false
;	call @end_drill
;	;{'G49 '}
;	{'G21'}
    if sHomestrbegin ne ''
        sHomestr = sHomestrbegin
        call @usr_prep_home_axis
    endif
    ;call @usr_optionalstop  ; !@#$%AC 0.5
endp

;-------------------

@end_program
    ; Handle output for end of program
    if bMultiplefixtures eq True
        bFromendprogram = True
        call @Multiple_Fixtures
    endif
    if bCooloffend and bCoolExist
        iCoolantM1 = iCoolantM1OFF
        iCoolantM2      = iCoolantM2OFF
        iCoolantM3      = iCoolantM3OFF
        iCoolantM4      = iCoolantM4OFF
        iCoolantM5      = iCoolantM5OFF
        iCoolantM6      = iCoolantM6OFF
        iCoolantM7      = iCoolantM7OFF
        iCoolantM8      = iCoolantM8OFF
        call @usr_coolant_output
    endif
    if bSpinoffend
        iSpindleDir = 5
        {nb}
        call @usr_spindle_mcode_output
    endif
    if sHomestrend ne ''
        sHomestr = sHomestrend
        call @usr_prep_home_axis
    endif
;    if change(iAbsincmode)
;	    {nb}
;	    call @usr_abs_inc_output
;    endif
    if change(iWorkoffset)
        {nb}
        call @usr_homenumber_output
    endif
    if bOptstpend
        call @usr_optionalstop
    endif
    if bToolChangeAtEnd
        {nb,'T'tool_number}
        {nb,cTCcodep}
        {nb,'T'next_tool_number}
    endif
    if iProgendmode eq 1
        {nb, 'G90'}
        {nb, 'M30 '}
    endif
    if iProgendmode eq 2
        {nb, 'G90'}
        {nb, 'M2 '}
    endif

endp

;-------------------

@end_of_file
    ; Handle end of file character
    if i4xIndexMode eq 2 and !bLimit_3axis ;Trig Macro
        call @usr_trig_macro_output
    endif
    if cPe ne ''
        {nl,cPb}
    endif
    if bMultiplefixtures eq True
        bFromendoffile = True
        call @Multiple_Fixtures
    endif
endp

;-------------------

@relative_mode
    ; Handle setting of IncrementalMode Gcode
    iAbsincmode = 91
endp

@absolute_mode
    ; Handle setting of AbsoluteMode Gcode
    iAbsincmode = 90
endp

@usr_abs_inc_output
    ; Handle output of AbsoluteMode Gcode
    {['G'iAbsincmode, ' ']}
    if change(iAbsincmode); !@#$% Force !change for variable
        change(iAbsincmode) = false
    endif
endp

;-------------------

@machine_plane
    ; Handle GPP direct call to @machine_plane
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may Sync with arc_zx_yz
    if machine_plane eq XY
        iMplane = 17
    endif
    if machine_plane eq ZX
        iMplane = 18
    endif
    if machine_plane eq YZ
        iMplane = 19
    endif
endp

@usr_mp_output
    ; Handle output of MachinePlane Gcode
    ; Use bStartFile variable to ignore this output at beginning of file
    {['G'iMplane' ']}
    if change(iMplane); !@#$% Force !change for variable
        change(iMplane) = false
    endif
endp

;-------------------

@home_number
    ; Handle setting WorkOffset Gcode
    if part_home_number eq 20
        ihome_number = iLhome_number
    else
        iLhome_number = part_home_number
        ihome_number = part_home_number
    endif
    if iWorkOffset_Method eq 0
        if iWorkOffsetmode eq 1
            if part_home_number <= 6
                cWo = 'G'
                if i4xIndexMode eq 0
                    iWorkoffset = 53 + mac_number              ; uncoment this line for same work offset number for all positions
                else
                    iWorkoffset = 53 + part_home_number    ; uncoment this line for different work offset number for all positions
                endif
            else
                cWo = 'G54.1 p'
                iWorkoffset = part_home_number - 6
            endif
        else
            if iWorkOffsetmode eq 2 or iWorkOffsetmode eq 3
                iWorkoffset = part_home_number
            endif
        endif
    else
        iWorkoffset = tonum(home_user_name)
    endif
endp

@usr_homenumber_output
    ; Handle output WorkOffset Gcode
    {[cWo,iWorkoffset' ']}
    if change(iWorkoffset); !@#$% Force !change for variable
        change(iWorkoffset) = false
    endif
endp

;-------------------

@change_tool
    ; Delayed Tool Change handling to @start_of_job to have access to Operation(Job) data
    nTcXnext = xnext
    nTcYnext = ynext
    nTcZnext = tool_start_plane
    nTcCnext = cnext
    bTlchg = true
    if first_tool
        sTnums = tostr(tool_number)
    endif
endp

@usr_ct
    ; Handle all aspects of Tool Change
    local integer count i
    local string tTnums
    if bMultiplefixtures eq True
        bFrombeginchangetool = True
        call @Multiple_Fixtures
    endif
    iTcnumber = iTcnumber + 1
    tTnums = sTnums
;    if !first_tool
;        count = 0
;        i = 2
;        while i > 1
;            i = instr(tTnums,tostr(tool_number)) + 1
;            tTnums = substr(tTnums,i,99)
;            count = count + 1
;        endw
;        sTnums = sTnums + tostr(tool_number)
;        iTcnumber = (tool_number * 100) + count
;    else
;        iTcnumber = (tool_number * 100) + 1
;    endif
    bStartFile = false
    if !first_tool
        call @usr_ct_before_notfirsttool
    endif
    if first_tool
        call @usr_ct_before_firsttool
    endif
    call @usr_ct_toolchange
    call @usr_tc_init_gmstates
    call @usr_ct_after
    if !bMultiplefixtures and !Bsubs
;		bSkipxyrapid = true
    endif
    if bMultiplefixtures eq True
        bFromendchangetool = True
        call @Multiple_Fixtures
    endif
endp

@usr_ct_before_notfirsttool
    ; Handle output before the next tool change
    ; This is not called before the first tool change
    local integer i poz1 l1b pr1
    local string msg1 msg1a msg1b
    if !bStopM00difftool
        if bCooloffend and bCoolExist
            iCoolantM1 = iCoolantM1OFF
            iCoolantM2 = iCoolantM2OFF
            iCoolantM3 = iCoolantM3OFF
            iCoolantM4 = iCoolantM4OFF
            iCoolantM5 = iCoolantM5OFF
            iCoolantM6 = iCoolantM6OFF
            iCoolantM7 = iCoolantM7OFF
            iCoolantM8 = iCoolantM8OFF
            call @usr_coolant_output
        endif
        if bSpinoffend
            iSpindleDir = 5
            {nb}
            call @usr_spindle_mcode_output
        endif
        if sHomestrtc ne ''
            sHomestr = sHomestrtc
            call @usr_prep_home_axis
        endif
        if bOptstptc
            {nb}
            call @usr_optionalstop
        endif
        if bNnumtc
            {nb}
            {nl,'N'iTcnumber' '}
        endif
        {nb, cCb,job_name,cCe}
        if msg ne ''
            i = 1
            while i < 50
                i = i + 1
                poz1=instr(msg,'\n')
                if poz1 eq 0
                    poz1=strlen(msg)
                    msg1=msg
                else
                    poz1 = poz1-2
                    msg1=left(msg,poz1)
                endif
                {nb, cCb,msg1,cCe}
                poz1=instr(msg,'\n')
                if poz1 eq 0
                    i = 51
                else
                    l1b=strlen(msg)-strlen(msg1)
                    pr1=poz1+1
                    msg1b=substr(msg,pr1,l1b)
                    msg=msg1b
                endif
            endw
        endif
    endif
    if bTcseperation
        {nl}
    endif
;	bSafetyprep = true
    call @usr_tc_init_gmstates
;	call @usr_abs_inc_output
    call @usr_mp_output
;	call @usr_compensation_output
;	skipline = false
;	call @end_drill
;	{'G00 '}
endp

@usr_ct_before_firsttool
    ; Handle output before the first tool change
    local integer i poz1 l1b pr1
    local string msg1 msg1a msg1b
    {nl}
    if bNnumtc
        {nl,'N'iTcnumber' '}
    endif
    {nb, cCb,job_name,cCe}
    if msg ne ''
        i = 1
        while i < 50
            i = i + 1
            poz1=instr(msg,'\n')
            if poz1 eq 0
                poz1=strlen(msg)
                msg1=msg
            else
                poz1 = poz1-2
                msg1=left(msg,poz1)
            endif
            {nb, cCb,msg1,cCe}
            poz1=instr(msg,'\n')
            if poz1 eq 0
                i = 51
            else
                l1b=strlen(msg)-strlen(msg1)
                pr1=poz1+1
                msg1b=substr(msg,pr1,l1b)
                msg=msg1b
            endif
        endw
    endif
    if sHomestrtc ne ''
        sHomestr = sHomestrtc
        call @usr_prep_home_axis
    endif
endp

@usr_ct_toolchange
    ; Handle G/M code output to make tool change
    {nb,'T'tool_number}
    if tool_message == '' then
        {' ' cCb'TOOL 'tool_number, ' - DIA '(tool_offset*2),cCe }
    else
        {' ' cCb tool_message,cCe}
    endif
    {nb,cTCcodes}
endp

@usr_ct_after
    ; Handle output after tool change
    ; *Note: Coolant & job Options need handling
    ; ---- 4x
;	if i4xIndexMode eq 2 and !bLimit_3axis ;Trig Macro
;		call @usr_r1pos_calc
;		call @usr_trig_macro_call
;		iWorkoffset = 112
;		nR1pos = 9999
;	endif
    ; ---- 4x
    imotionmode = 0
    {nb, 'G'iMotionmode:mcode_f ' '}
    call @machine_plane
    change(implane) = true
    call @usr_mp_output
    {'G21 '}
    skipline = false
    call @usr_heightcomp_off
    skipline = false
    iDrillmode = 9999
    call @end_drill
    imotionmode = 0
    change(	imotionmode) = false
    call @usr_abs_inc_output
    skipline = true
    if bCoolspinaftertc
        skipline = true
        call @start_tool
        if bCoolExist
            skipline = true
            call @usr_coolant
        endif
        xpos = nTcXnext
        ypos = nTcYnext
        cpos = nTcCnext
        change(xpos) = true
        change(ypos) = true
        change(cpos) = true
        change(zpos) = false
        call @usr_rapid
        call @usr_heightcomp_on
    else
        xpos = nTcXnext
        ypos = nTcYnext
        cpos = nTcCnext
        change(xpos) = false
        change(ypos) = false
        change(cpos) = true
        change(zpos) = false
        call @usr_rapid
        change(xpos) = true
        change(ypos) = true
        change(cpos) = false
        change(zpos) = false
        call @usr_rapid
        skipline = false
        call @start_tool
        call @usr_heightcomp_on
        if bCoolExist
            skipline = false
            call @usr_coolant
        endif
    endif
    if bToolPreselect
        {nb,'T'next_tool_number}
    endif
endp

@usr_tc_init_gmstates
    ; Handle initializing gmcodes for correct modality after tool change
    if first_tool
        iMotionmode = 9999
        iDiametercomp = 40
        change(iAbsincmode) = true
        change(iWorkoffset) = true
        change(iDiameteroffset) = false
        iHeightcomp = 9999
        iDrillmode = 9999
        iCoolantM1 = iCoolantM1OFF
        iCoolantM2 = iCoolantM2OFF
        iCoolantM3 = iCoolantM3OFF
        iCoolantM4 = iCoolantM4OFF
        iCoolantM5 = iCoolantM5OFF
        iCoolantM6 = iCoolantM6OFF
        iCoolantM7 = iCoolantM7OFF
        iCoolantM8 = iCoolantM8OFF
    else
        if bSafetyprep
            call @machine_plane
            change(iMplane) = true
            change(iAbsincmode) = true
            change(iDiametercomp) = true
            ;iDrillmode = 9999  !@#$%AC
            bSafetyprep = false
        else
            iMotionmode = 9999
            if bWorkoffsettc
                change(iWorkoffset) = true
            endif
            change(iAbsincmode) = true
            iDiametercomp = 40
            change(iDiameteroffset) = false
            iHeightcomp = 9999
            ;iDrillmode = 9999   !@#$%AC
            iCoolantM1 = iCoolantM1OFF
            iCoolantM2 = iCoolantM2OFF
            iCoolantM3 = iCoolantM3OFF
            iCoolantM4 = iCoolantM4OFF
            iCoolantM5 = iCoolantM5OFF
            iCoolantM6 = iCoolantM6OFF
            iCoolantM7 = iCoolantM7OFF
            iCoolantM8 = iCoolantM8OFF
            change(nRapidfeed) = true
            ; ---- 4x
            nR1pos = 9999
            ; ---- 4x
        endif
    endif
endp

@usr_heightcomp_on
    ; Handle line to turn on Height Compensation (Typically after tool change)
    iHeightcomp = 43
    {nb, 'G'iHeightcomp, ' H'tool_number' '}
    skipline = false
    zpos = nTcZnext
    change(xpos) = false
    change(ypos) = false
    call @rapid_move
endp

@usr_heightcomp_off
    ; Handle line to turn off Height Compensation (Typically don't use)
    iHeightcomp = 49
    if change(iHeightcomp)
        {nb, 'G'iHeightcomp' '}
    endif
endp

@usr_coolant
    ; Handle setting of coolant variable
    ; When GlobalCode = 0, we use UserOption for thier default CoolantCode
    ;  *Note: PartOptions default to 0 in SolidCAM
    ;  *Note: Some customers default with M8(coolant), but some use M7(air) or M9(nothing)
    ; We use GlobalCode for coolant unless
    ;  the user inputs a number for LocalCode (Misc Params--Operation)
    if flood_coolant eq 1
        iCoolantM1 = iCoolantM1ON
    endif
    if flood_coolant eq 0 or flood_coolant eq 2
        iCoolantM1 = iCoolantM1OFF
    endif
    if Mist_coolant eq 1
        iCoolantM2 = iCoolantM2ON
    endif
    if Mist_coolant eq 0 or Mist_coolant eq 2
        iCoolantM2 = iCoolantM2OFF
    endif
    if HP_Flood_coolant eq 1
        iCoolantM3 = iCoolantM3ON
    endif
    if HP_Flood_coolant eq 0 or HP_Flood_coolant eq 2
        iCoolantM3 = iCoolantM3OFF
    endif
    if LP_Flood_coolant eq 1
        iCoolantM4 = iCoolantM4ON
    endif
    if LP_Flood_coolant eq 0 or LP_Flood_coolant eq 2
        iCoolantM4 = iCoolantM4OFF
    endif
    if Through_coolant eq 1
        iCoolantM5 = iCoolantM5ON
    endif
    if Through_coolant eq 0 or Through_coolant eq 2
        iCoolantM5 = iCoolantM5OFF
    endif
    if LP_Through_coolant eq 1
        iCoolantM6 = iCoolantM6ON
    endif
    if LP_Through_coolant eq 0 or LP_Through_coolant eq 2
        iCoolantM6 = iCoolantM6OFF
    endif
    if Air_Blast_coolant eq 1
        iCoolantM7 = iCoolantM7ON
    endif
    if Air_Blast_coolant eq 0 or Air_Blast_coolant eq 2
        iCoolantM7 = iCoolantM7OFF
    endif
    if air_through_coolant eq 1
        iCoolantM8 = iCoolantM8ON
    endif
    if air_through_coolant eq 0 or air_through_coolant eq 2
        iCoolantM8 = iCoolantM8OFF
    endif
    call @usr_coolant_output
endp

@usr_coolant_output
    ; Handle output of coolant variable
    if change(iCoolantM1)
        {nb,['M'iCoolantM1:mcode_f' ']}
        if iCoolantM1 eq iCoolantM1OFF
            change(iCoolantM2) = false
            change(iCoolantM3) = false
            change(iCoolantM4) = false
            change(iCoolantM5) = false
            change(iCoolantM6) = false
            change(iCoolantM7) = false
        endif
    endif
    if change(iCoolantM2)
        {nb,['M'iCoolantM2:mcode_f' ']}
        if iCoolantM2 eq iCoolantM2OFF
            change(iCoolantM3) = false
            change(iCoolantM4) = false
            change(iCoolantM5) = false
            change(iCoolantM6) = false
            change(iCoolantM7) = false
        endif
    endif
    if change(iCoolantM3)
        {nb,['M'iCoolantM3:mcode_f' ']}
        if iCoolantM3 eq iCoolantM3OFF
            change(iCoolantM4) = false
            change(iCoolantM5) = false
            change(iCoolantM6) = false
            change(iCoolantM7) = false
        endif
    endif
    if change(iCoolantM4)
        {nb,['M'iCoolantM4:mcode_f' ']}
        if iCoolantM4 eq iCoolantM4OFF
            change(iCoolantM5) = false
            change(iCoolantM6) = false
            change(iCoolantM7) = false
        endif
    endif
    if change(iCoolantM5)
        {nb,['M'iCoolantM5:mcode_f' ']}
        if iCoolantM5 eq iCoolantM5OFF
            change(iCoolantM6) = false
            change(iCoolantM7) = false
        endif
    endif
    if change(iCoolantM6)
        {nb,['M'iCoolantM6:mcode_f' ']}
        if iCoolantM6 eq iCoolantM6OFF
            change(iCoolantM7) = false
        endif
    endif
    if change(iCoolantM7)
        {nb,['M'iCoolantM7:mcode_f' ']}
    endif
    if change(iCoolantM8)
        {nb,['M'iCoolantM8:mcode_f' ']}
    endif
    if  !change(iCoolantM1) or  !change(iCoolantM2) or !change(iCoolantM3) or  !change(iCoolantM4) or !change(iCoolantM5) or  !change(iCoolantM6) or !change(iCoolantM7) or !change(iCoolantM8)
        skipline = TRUE
    endif
endp
;--------------------

@start_of_job
    ; Handle what happens at start of operation(job)
    ; If using Subs we do not make tool change in @start_of_job
    call @home_number
    if rot_axis_type ne axis4_none
        Xpos = 0
        Xnext = 0
        nTcXnext = 0
    endif
    if bSubs
        {nb, cCb,job_name,cCe}
        change(xpos) = true
        change(ypos) = true
        change(cpos) = true
        change(nr1pos) = true
    else
        if bTlchg
            call @usr_ct
            bTlchg = false
        else
            {nb}
            if bNnumtc
                sTnums = sTnums + tostr(tool_number:'2/2.0')
                iTcnumber = iTcnumber + 1
                {nl,'N' iTcnumber' '}
            else
                {nb}
            endif
            {nb, cCb,job_name,cCe}
            ; ---- 4x
            ;   - Set Rotary Position
            call @usr_r1pos_calc
            if change(nR1pos)
                if sHomestrrot ne ''
                    sHomestr = sHomestrrot
                    call @usr_prep_home_axis
                else
                    iMotionmode = 0
                    change(iMotionmode) = true
                    {nb,['G'iMotionmode:mcode_f ' '],['Z'tool_z_level ' ']}
                endif
                iMotionmode = 0
                change(iMotionmode) = true
                xpos = xnext
                ypos = ynext
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iAbsincmode ' '],[cWo,iWorkoffset' '],['X'xpos ' '],['Y'ypos ' ']}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iAbsincmode ' '],[cWo,iWorkoffset' '],[cR1,nR1pos ' ']}
                change(iMotionmode) = false
                change(iMplane) = false
                change(iWorkoffset) = false
                change(iAbsincmode) = false
                change(nR1pos) = false
                change(xpos) = FALSE
                change(ypos) = FALSE
                change(zpos) = false
;				bSkipxyrapid = true
            endif
        endif
    endif
    if job_type eq 'drill_hr' or X5_job or transform_type eq 3
        bSkipxyrapid = false
    endif
    if bCoolExist and !bsubs
        skipline = TRUE
        call @usr_coolant
    endif
endp

;--------------------

@end_of_job
    ; Handle what happens at end of operation(job)
    ; If using Subs we do not make tool change in @start_of_job
    if bStopM00
        if tool_number eq next_job_tool_number
            call @usr_StopM00_sametool
        else
            call @usr_StopM00_difftool
        endif
    endif
    bSkipxyrapid = false
    bStopM00difftool = false
    iPworkoffset = iWorkoffset
    ; ---- 4x
    ;if tool_z_level < tool_start_plane
    ;    Print 'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'
    ;    {nl,'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'}
    ;endif
    nPtool_z_level = tool_z_level
    nPtool_start_plane = tool_start_plane
    cpos = 0
    apos = 0
    ; ---- 4x
;    if bCoolExist and !bsubs
;	    call @usr_coolant
;    endif
endp

;-------------------

@rapid_move
    ; Handle GPP direct call to Rapid Move (G00)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @rapid_move, @move_5x, @move_4x, @move4x_polar, @move4x_cartesian
    call @usr_rapid
endp

@usr_rapid
    ; Handle output for Rapid Move (G00)
    ; Note: XYZ not allowed together on a single line
    ; ---- 4x
    ;   - Set Rotary Position
    call @usr_r1pos_calc
    if change(cpos) and !change(xpos) and !change(ypos) and !change(zpos) and !change(nR1pos) ;Ignore cpos prepositioning, handled at toolchange
        skipline = false
    endif
    ; ---- 4x
    if !bSkipxyrapid
        if !bSyncdrapid
            if job_type eq '3-d model'
                iMotionmode = 1
            else
                iMotionmode = 0
            endif
        else
            iMotionmode = 0
        endif
        if (change(xpos)or change(ypos)) and change(zpos) ;!@#$% clear change
            bTest = true
        endif
        {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iAbsincmode ' '],[cWo,iWorkoffset' '],['X'xpos ' '],['Y'ypos ' '],[cR1,nR1pos ' ']}
        change(cWo) = false
        change(cR1) = false
        if change(zpos)
            if bTest  ;!@#$% clear change
                {nb,['Z'zpos ' ']}
                bTest = false
            else
                {'Z'zpos ' '}
            endif
        endif
        if !bSyncdrapid
            if job_type eq '3-d model'
                {['F'nRapidfeed' ']}
            endif
        endif
        bSkipxyrapid = false
    else
        {nb,['Z'zpos ' ']}
        if !bSyncdrapid
            if job_type eq '3-d model'
                {['F'nRapidfeed' ']}
            endif
        endif
        bSkipxyrapid = false
    endif
    if change(iMotionmode)
        change(iMotionmode) = false
    endif
    if change(iMplane)
        change(iMplane) = false
    endif
    if change(iWorkoffset)
        change(iWorkoffset) = false
    endif
    if change(iAbsincmode)
        change(iAbsincmode) = false
    endif
    if change(nRapidfeed)
        change(nRapidfeed) = false
    endif
    if !bSyncdrapid
        bFeedoutput        = true
    endif
endp

;-------------------

@line
    ; Handle GPP direct call to Line Movement (G01)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @line, @line_5x, @line_4x, @line4x_polar, @line4x_cartesian
    call @usr_line
endp

@usr_line
    ; Handle output for line movement (G01)
    ; ---- 4x
    ;   - Set Rotary Position
    call @usr_r1pos_calc
    if rot_axis_type ne axis4_none or X5_job
        ;iFeedType = 93  ;Inverse Feed
        ;feed = (1/(inverse_feed))
        ;if tool_path_type eq 'start_approach'
        ;    feed = z_feed
        ;else
        feed = feed_rate
        ;endif
        if feed ne prevFeed
            change(feed) = true
        else
            change(feed) = false
        endif
    else
        iFeedType = 94
        if change(iFeedType)
            change(feed) = true
        endif
    endif
    ; ---- 4x
    if bFeedoutput
        change(feed) = true
        bFeedoutput  = false
    endif
    iMotionmode = 1
    {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iDiametercomp' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' ']}
    {['G'iFeedType' '],['D'iDiameteroffset' '],['X'xpos ' '],['Y'ypos ' '],['Z'zpos ' '],[cR1,nR1pos ' '],['F'feed ' ']}
    if change(iMotionmode)
        change(iMotionmode)     = false
    endif
    if change(iMplane)
        change(iMplane)         = false
    endif
    if change(iDiametercomp)
        change(iDiametercomp)   = false
    endif
    if change(iWorkoffset)
        change(iWorkoffset)     = false
    endif
    if change(iAbsincmode)
        change(iAbsincmode)     = false
    endif
    if change(iDiameteroffset)
        change(iDiameteroffset) = false
    endif
    if change(iFeedType)
        change(iFeedType) = false
    endif
    prevFeed = feed
    change(nRapidfeed)          = true
endp

; -----------
@arc
    ; SolidCAM call to normal arc movement
    ; We do not use this procedure to output code
    ; We create our own procedure for this so that we have one arc formatting section
    call @usr_arc
endp

@arc_yz
    ; SolidCAM call to YZ arc movement
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we have one arc formatting section
    call @usr_arc
endp

@arc_zx
    ; SolidCAM call to ZX arc movement
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we have one arc formatting section
    call @usr_arc
endp

@usr_arc
    ; Handle output for arc movement (G02/G03)
    if bFeedoutput
        change(feed) = true
        bFeedoutput  = false
    endif
    if arc_direction eq CCW then
        iMotionmode = 3
    else
        iMotionmode = 2
    endif
    if arc_plane eq XY
        iMplane = 17
    endif
    if arc_plane eq ZX
        iMplane = 18
    endif
    if arc_plane eq YZ
        iMplane = 19
    endif
    {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iDiametercomp' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' ']}
    {['D'iDiameteroffset' '],['X'xpos ' '],['Y'ypos ' '],['Z'zpos ' ']}
    if arc_plane eq XY then
        if iArcmode eq 1 or (arc_size eq 360 and iArcmode eq 3)
            {'I'xcenter ' ', 'J'ycenter ' '}
        endif
        if iArcmode eq 2 or (arc_size eq 360 and iArcmode eq 4)
            {'I'xcenter_rel ' ', 'J'ycenter_rel ' '}
        endif
        if (iArcmode eq 3 or iArcmode eq 4) and arc_size ne 360
            if arc_size >= 180 then
                radius = -radius
            endif
            {'R'radius' '}
        endif
    endif
    if arc_plane eq ZX then
        if iArcmode eq 1 or (arc_size eq 360 and iArcmode eq 3)
            {'I'xcenter ' ', 'K'zcenter ' '}
        endif
        if iArcmode eq 2 or (arc_size eq 360 and iArcmode eq 4)
            {'I'xcenter_rel ' ', 'K'zcenter_rel ' '}
        endif
        if (iArcmode eq 3 or iArcmode eq 4) and arc_size ne 360
            if arc_size >= 180 then
                radius = -radius
            endif
            {'R'radius' '}
        endif
    endif
    if arc_plane eq YZ then
        if iArcmode eq 1 or (arc_size eq 360 and iArcmode eq 3)
            {'J'ycenter ' ', 'K'zcenter ' '}
        endif
        if iArcmode eq 2 or (arc_size eq 360 and iArcmode eq 4)
            {'J'ycenter_rel ' ', 'K'zcenter_rel ' '}
        endif
        if (iArcmode eq 3 or iArcmode eq 4) and arc_size ne 360
            if arc_size >= 180 then
                radius = -radius
            endif
            {'R'radius' '}
        endif
    endif
    {['F'feed ' ']}
    if change(iMotionmode)
        change(iMotionmode)     = false
    endif
    if change(iMplane)
        change(iMplane)         = false
    endif
    if change(iDiametercomp)
        change(iDiametercomp)   = false
    endif
    if change(iWorkoffset)
        change(iWorkoffset)     = false
    endif
    if change(iAbsincmode)
        change(iAbsincmode)     = false
    endif
    if change(iDiameteroffset)
        change(iDiameteroffset) = false
    endif
    change(nRapidfeed)          = true
endp

;-------------------

@compensation
    ; SolidCAM call for diameter compensation
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we..
    ;   have can control placement during @line,@arc
    if side eq COMP_LEFT then
        iDiametercomp = 41
        change(iDiameteroffset) = true
    endif
    if side eq COMP_RIGHT then
        iDiametercomp = 42
        change(iDiameteroffset) = true
    endif
    if side eq COMP_OFF then
        iDiametercomp = 40
        change(iDiameteroffset) = false
    endif
endp

@usr_compensation_output
    ; Handle line for diameter compensation output (Radial)
    if change(iDiametercomp)
        if iDiametercomp eq 40
            {'G'iDiametercomp' '}
        else
            {'G'iDiametercomp, ' D'tool_number' '}
        endif
    endif
endp

;-------------------

@usr_optionalstop
    ; Handle line for Optional Stop gmcode
    iStopmode = 1
    {nb, 'M'iStopmode:mcode_f' '}
endp

@usr_forcedstop
    ; Handle line for forced Stop gmcode
    iStopmode = 0
    {nb, 'M'iStopmode:mcode_f' '}
endp

@usr_StopM00_sametool
    ; Handle output for forced stopM00 between operations using the same tool
    if bCoolExist
        iCoolantM1 = iCoolantM1OFF
        iCoolantM2 = iCoolantM2OFF
        iCoolantM3 = iCoolantM3OFF
        iCoolantM4 = iCoolantM4OFF
        iCoolantM5 = iCoolantM5OFF
        iCoolantM6 = iCoolantM6OFF
        iCoolantM7 = iCoolantM7OFF
        iCoolantM8 = iCoolantM8OFF
        call @usr_coolant_output
    endif
    iSpindleDir = 5
    {nb}
    call @usr_spindle_mcode_output
    if sHomestrstpsame ne ''
        sHomestr = sHomestrstpsame
        call @usr_prep_home_axis
    endif
    call @usr_forcedstop
    sUsrmsg = sStopMessage
    call @usr_message
    {nb}
    call @usr_abs_inc_output
    call @m_feed_spin
    call @usr_spindle_mcode_output
    change(xpos) = true
    change(ypos) = true
    change(zpos) = false
    call @rapid_move
    call @usr_heightcomp_on
endp

@usr_StopM00_difftool
    ; Handle output for forced stopM00 between operations using different tools
    if bCoolExist
        iCoolantM1 = iCoolantM1OFF
        iCoolantM2 = iCoolantM2OFF
        iCoolantM3 = iCoolantM3OFF
        iCoolantM4 = iCoolantM4OFF
        iCoolantM5 = iCoolantM5OFF
        iCoolantM6 = iCoolantM6OFF
        iCoolantM7 = iCoolantM7OFF
        iCoolantM8 = iCoolantM8OFF
        call @usr_coolant_output
    endif
    iSpindleDir = 5
    {nb}
    call @usr_spindle_mcode_output
    if sHomestrstpdiff ne ''
        sHomestr = sHomestrstpdiff
        call @usr_prep_home_axis
    endif
    call @usr_forcedstop
    sUsrmsg = sStopMessage
    call @usr_message
    bStopM00difftool = true
endp

;-------------------

@change_ref_point
    ; @change_ref_point Not Supported in this template

endp

;-------------------

@rotate
    ; @rotate Not Supported in this template
endp

;-------------------

@mirror
    ; @mirror Not Supported in this template
endp

;-------------------

@fourth_axis
    ; @fourth_axis Not Supported in this template
endp
;-------------------

@message
    ; We don't use messages directly from SolidCAM
endp

@usr_message
    ; Handle output for messages
    ; We don't use messages directly from SolidCAM
    {nb, cCb,sUsrmsg,cCe}
endp

;-------------------

@drill
    ; Handle output for drill cycles
    local string p_f
    p_f = '5.1(p)'
    {nb,'Z'zpos' '}
    if drill_type eq G81
        iDrillmode = 81
        {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' F'feed ' '}
    endif
    if drill_type eq G82
        iDrillmode = 82
        {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' P'P_Dwell:p_f' F'feed' '}
    endif
    if drill_type eq G83
        iDrillmode = 83
        if P_Dwell eq 0
            change(P_Dwell) = false
        endif
        if I_FirstPeck eq 0
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' Q'Q_Peck,[' P'P_Dwell:p_f],' F'feed' '}
        else
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' I'I_FirstPeck' J'J_ReduceAmount' K'K_MinimumDepth,[' P'P_Dwell:p_f],' F'feed' '}
        endif
    endif
    if drill_type eq G73
        iDrillmode = 73
        if P_Dwell eq 0
            change(P_Dwell) = false
        endif
        if I_FirstPeck eq 0
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' Q'Q_Peck' K'K_MinimumDepth,[' P'P_Dwell:p_f],' F'feed' '}
        else
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' I'I_FirstPeck' J'J_ReduceAmount' K'K_MinimumDepth,[' P'P_Dwell:p_f],' F'feed' '}
        endif
    endif
    if drill_type eq G84
        iDrillmode = 84
        if cG84p ne ''
            {nb,cG84p}
        endif
        if bG84spin
            change(spin) = true
        else
            change(spin) = false
        endif
        {nb, cDr,cG84 ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z,[' S'spin:fG84spin],' F'(tool_drill_lead*spin) ' '}
    endif
    if drill_type eq G74  ;!@#$%AC 0.4
        iDrillmode = 74
        {nb}
        iSpindleDir = 4
        bUsrcall = true
        call @usr_spindle_mcode_output
        if cG84p ne ''
            {nb,cG84p}
        endif
        if bG84spin
            change(spin) = true
        else
            change(spin) = false
        endif
        {nb, cDr'G'iDrillmode  ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z,[' S'spin:fG84spin],' F'(tool_drill_lead*spin) ' '}
    endif
    ;if drill_type eq G84_Peck      ;!@#$%AC 0.4 deleted because 12 cycle limit
    ;    iDrillmode = 84
    ;    if cG84p ne ''
    ;       {nb,cG84p}
    ;    endif
    ;    if bG84spin
    ;        change(spin) = true
    ;    else
    ;        change(spin) = false
    ;    endif
    ;    {nb, cDr,cG84 ' Z'drill_lower_z' R'drill_upper_z' 'cCycs,['S'spin:fG84spin' '],'F'(tool_drill_lead*spin) ' '}
    ;endif
    if drill_type eq G85
        if P_Dwell eq 0
            iDrillmode = 85
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' F'feed ' '}
        else
            iDrillmode = 89
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' P'P_Dwell:p_f' F'feed' '}
        endif
    endif
    if drill_type eq G86
        iDrillmode = 86
        {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' F'feed ' '}
    endif
    if drill_type eq G87  ;!@#$%AC 0.4
        if P_Dwell eq 0
            iDrillmode = 87
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' Q'Q_Shift' F'feed ' '}
        else
            iDrillmode = 87
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' P'P_Dwell:p_f' Q'Q_Shift' F'feed' '}
        endif
    endif
    if drill_type eq G76  ;!@#$%AC 0.4
        if P_Dwell eq 0
            iDrillmode = 76
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' Q'Q_Shift' F'feed ' '}
        else
            iDrillmode = 76
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' P'P_Dwell:p_f' Q'Q_Shift' F'feed' '}
        endif
    endif
    if drill_type eq G88
        if P_Dwell eq 0
            iDrillmode = 88
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' F'feed ' '}
        else
            iDrillmode = 88
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' P'P_Dwell:p_f' F'feed' '}
        endif
    endif
    if drill_type eq G89
        if P_Dwell eq 0
            iDrillmode = 89
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' F'feed ' '}
        else
            iDrillmode = 89
            {nb, cDr'G'iDrillmode ' X'xpos' Y'ypos' Z'drill_lower_z' R'drill_upper_z' P'P_Dwell:p_f' F'feed' '}
        endif
    endif
endp

;-------------------

@drill_point
    ; Handle output for drill positions
    ;local integer i                                                                     ;!@#$%AC 0.4 deleted because 12 cycle limit
    ;if drill_type eq G84_Peck
    ;    iNumpecks = (drill_depth/Q_Peck)+1.
    ;	nCorrectedpeck = drill_depth/iNumpecks
    ;    i = 1
    ;    while i <= iNumpecks
    ;		{nb,'X'xpos ' ', 'Y'ypos ' ', 'Z'(drill_upper_z-(nCorrectedpeck*i))' '}
    ;	    i = i + 1
    ;	endw
    ;else
    if !first_drill then                                               ;!@#$%AC 0.5 uncommented from 0.4
        {nb,['X'xpos ' '], ['Y'ypos ' '], ['Z'zpos ' ']}
    endif
    ;endif
endp


;-------------------

@end_drill
    ; Handle output to cancel drill cycles
    iDrillmode = 80
    if change(iDrillmode)
        {nb, 'G'iDrillmode' '}
    endif
    iMotionmode = 9999
endp

;-------------------

@m_feed_spin
    ; Handle output for spindle change
    if tool_direction eq CW then
        iSpindleDir = 3
    else
        iSpindleDir = 4
    endif
    if change(spin)
        call @usr_spindle_output
    endif
endp

@start_tool
    ; Handle setting and output for spindle start
    if tool_direction eq CW then
        iSpindleDir = 3
    else
        iSpindleDir = 4
    endif
    call @usr_spindle_output
    call @usr_spindle_mcode_output
endp

@usr_spindle_output
    ; Handle output for spindle
    {nb,'S'spin:integer_def_f ' '}
endp

@usr_spindle_mcode_output
    ; Handle output for spindle
    {'M'iSpindleDir:mcode_f ' '}
endp

;-------------------

@offset_change
    ; Handle setting of Diameter offset
    iDiameteroffset = d_offset
    change(iDiameteroffset) = false
endp

;-------------------

@job_plane
    ; @job_plane Not Supported in this template
endp

;-------------------

@call_proc
    ; Handle call to subroutine
    call @home_number
    if bTlchg
        call @usr_ct
        bTlchg = false
    else
        call @usr_r1pos_calc
        if rot_axis_type ne axis4_none
            Xpos = 0
            Xnext = 0
            nTcXnext = 0
        else
            xpos = xnext
        endif
        ypos = ynext
        zpos = tool_start_plane
        if change(nR1pos)
            if sHomestrrot ne ''
                sHomestr = sHomestrrot
                call @usr_prep_home_axis
            endif
            iMotionmode = 0
            {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iAbsincmode ' '],[cWo,iWorkoffset' '],['X'xpos ' '],['Y'ypos ' '],[cR1,nR1pos ' ']}
            call @usr_heightcomp_on
;			bSkipxyrapid = true
        else
            iMotionmode = 0
            {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],['G'iAbsincmode ' '],[cWo,iWorkoffset' '],['X'xpos ' '],['Y'ypos ' ']}
        endif
    endif
    {nb, 'M98 P'label}
    {[' ('message, ')']}
endp

;-------------------

@proc
    ; Handle beggining of subroutine
    {nl, 'O'label}
endp

;-------------------

@end_proc
    ; Handle end of subroutine
    {nb, 'M99'}
endp

;----------------

@loop_matrix_info
    bSkipxyrapid = false
endp
@loop
    ; Loops Not Supported in this template
    if bTraceUsrcall
        if bUsrcall
            {nl,'>>>>UserCalled @loop<<<<<    '}
            bUsrcall = false
        endif
    endif
endp

;----------------

@end_loop
    ; Loops Not Supported in this template
    if bTraceUsrcall
        if bUsrcall
            {nl,'>>>>UserCalled @end_loop<<<<<    '}
            bUsrcall = false
        endif
    endif
endp

;-------------------

@usr_prep_home_axis
    ; Handle parsing of homing string and preping of output for homing
    local integer i line l mode p1
    local string s s1 l1 pstr
    s = sHomestr                               ;Original String
    s1 = s                                     ;Temp String
    l = strlen(s1)                             ;Get string length of Temp String
    ;*Pull out Homing mode
    i = 1
    while i < 50
        i = i + 1
        p1 = instr(s1,':')                         ;Find the position of first ":"
        l1 = left(s1,p1-1)                         ;Pull out the left of first ":"
        mode = tonum(l1)                           ;Convert string into Integer for "Mode" variable
        s1 = substr(s1,p1+1,l)                     ;Remove Homing mode from Temp String
        l = strlen(s1)                             ;Get string length of Temp String
        ;*Pull out Preperation String
        p1 = instr(s1,':')                         ;Find the position of second ":"
        if p1 ne 0                                 ;Check if PrepStr is defined
            pstr = left(s1,p1-1)                   ;Pull out the left of second ":"
            s1 = substr(s1,p1+1,l)                 ;Remove PrepString from Temp String
            l = strlen(s1)                         ;Get string length of Temp String
        endif
        ;*Pull out homing lines and send to output procedure
        p1 = instr(s1,';')                      ;Find the position of ";"
        if p1 ne 0
            line = line + 1                     ;Keep track of lines. Not Used!!
            l1 = left(s1,p1-1)                  ;Pull out the left of ";"
            iHomingmode = mode                  ;Send Homing Mode
            cHomep = pstr                       ;Send Preperation String
            sHomeline = l1                      ;Send Homing Line
            call @usr_home_axis
        else
            line = line + 1                     ;Keep track of lines. Not Used!!
            iHomingmode = mode                  ;Send Homing Mode
            cHomep = pstr                       ;Send Preperation String
            sHomeline = s1                      ;Send Homing Line
            call @usr_home_axis
            i = 50                              ;Force end of While-Loop
        endif
        if i ne 50
            s1 = substr(s1,p1+1,l)              ;Remove Homing mode from Temp String
            l = strlen(s1)                      ;Get string length of Temp String
        endif
    endw
endp

@usr_home_axis
    ; Handle output for homing the X-axis
    local integer sav_iWorkOffset
    sav_iWorkOffset = iWorkOffset
    if iHomingmode eq 1
        {nb,'G28 'sHomeline}
    endif
    if iHomingmode eq 2
        {nb}
        iAbsincmode = 91
        change(iAbsincmode) = true
        {cHomep}
        call @usr_abs_inc_output
        {'G28 '}
        { sHomeline}
        iAbsincmode = 90
        change(iAbsincmode) = true
    endif
    if iHomingmode eq 3 or iHomingmode eq 4
        if iWorkOffsetmode eq 1 or iWorkOffsetmode eq 3
            iWorkOffset = 53
            {nb,cHomep,['G'iWorkoffset' ']}
        endif
        if iWorkOffsetmode eq 2
            iWorkOffset = 0
            {nb,cHomep,[cWo,iWorkoffset' ']}
        endif
        call @usr_abs_inc_output
        { sHomeline}
        iWorkOffset = sav_iWorkOffset
        if iHomingmode eq 3
            change(iWorkOffset) = false
        endif
    endif
    if iHomingmode eq 5
        {nb,cHomep'G30 'sHomeline}
    endif
    if iHomingmode eq 6
        {nb}
        {cHomep}
        iAbsincmode = 91
        change(iAbsincmode) = true
        call @usr_abs_inc_output
        {'G30 '}
        { sHomeline}
        iAbsincmode = 90
        change(iAbsincmode) = true
    endif
    if iHomingmode eq 7
        {nb,cHomep'G90 G54 'sHomeline}
    endif
endp

;-------------------

@usr_campart_path
    ; Handle output for spindle
    iSlength_g_file_name = strlen( g_file_name)
    iSlength_full_g_file_name = strlen(full_g_file_name)
    iSlengthcampartpath = iSlength_full_g_file_name - iSlength_g_file_name
    sCamfilepath = left(full_g_file_name,iSlengthcampartpath)
endp

;-------------------

@Multiple_Fixtures
    ; Handle multiple fixture support
    local integer i
;----From tools 2 and up
;----Closes the sSubspath(tempfile) for the previous tool change
;----Runs loop to print G5x and copy in the tempfile
;----Sets the tempfile to new name for next tool
    if bFrombeginchangetool eq True
        if !first_tool
            {nl,'!!close file=' sSubspath '!!'}
            i = 1
            while i <= iNumber_of_Fixtures
                {nl,cCb'-----LOOPING CODE-----'cCe}
                if i ne 1
                    {nb,cWo,((iWorkoffset-1)+i)}
                endif
                {nl,'!!copy file=' sSubspath '!!'}
                i = i + 1
            endw
            sSubspath = sCamfilepath + 'TEMPFILE' + tostr(iTcnumber:'5.0(n)')
        endif
        bFrombeginchangetool = False
    endif

;----At end of tool_change
;----Opens tempfile to print out gcode
    if bFromendchangetool eq True
        sSubspath = sCamfilepath + 'TEMPFILE' + tostr(iTcnumber:'5.0(n)')
        {nl,'!!open file=' sSubspath '!!'}
        bFromendchangetool = False
    endif

;----At end_program
;----Closes the sSubspath(tempfile) for the current tool change
;----Runs loop to print G5x and copy in the tempfile
    if bFromendprogram eq True
        {nl,'!!close file=' sSubspath '!!'}
        i = 1
        while i <= iNumber_of_Fixtures
            {nl,cCb'-----LOOPING LAST TOOL CHANGE CODE-----'cCe}
            if i ne 1
                {nb,cWo,((iWorkoffset-1)+i)}
            endif
            {nl,'!!copy file=' sSubspath '!!'}
            i = i + 1
        endw
        bFromendprogram = False
    endif

;----At eng_of_file
;----Delete all tempfiles
    if bFromendoffile eq True
        i = 1
        while i <= iTcnumber
            sSubspath = sCamfilepath + 'TEMPFILE' + tostr(i:'5.0(n)')
            {nl,'!!delete file=' sSubspath '!!'}
            i = i + 1
        endw
        bFromendoffile = false
    endif

endp

;-------------------

@usr_r1pos_calc
    ; Calculate Rotary 1 Position (Main Spindle)
    ; tmatrix + 4th Transform + cpos + 5xapos
    ; Note: Angular Feed Formula fc = f*(180/(pi*r))
    ; Note: fc=deg/min, f=linear feed
    nR1postmatrix = -angle_4x_around_y * iR1dir                        ;Rotary from CoordSys (tmatrix)
    nR1postransform = (-angle) * iR1dir                               ;Rotary from 4x-Transform
    nR1poscpos = (-cpos) * iR1dir                                     ;Rotary from C-axis cutting
    nR1pos5x = (-bpos) * iR1dir                                       ;Rotary from 4/5x Simulatenous
    nR1pos = nR1postmatrix + nR1postransform + nR1poscpos + nR1pos5x
    ;{nb,'Updated Position =' cpos}
    ;{nb,'Updated Position =' nR1pos}
    if bLimit_3axis
        change(nR1pos) = false
    endif
    if nPR1pos ne nR1pos
        change(nR1pos) = TRUE
;    else
;        change(nR1pos) = FALSE
    endif
    nPR1pos = nR1pos
endp

@usr_4x_index
    ; Handle 4x indexing (Rotary moves between operations)
    ;4x-Indexing control (0=Simple Rotation, 1=New WorkOffset, 2=Trig Macro)
    ;4x-Index Clearance control (0=Z-Homing, 1=Z-Tool_Z_Level, 2=Z-Tool_start_plane)

    call @usr_r1pos_calc
    if change(nR1pos)
        if i4xIndexMode eq 0 ;Simple Rotation
            if i4xIndexClearanceMode eq 0
                if sHomestrrot ne ''
                    sHomestr = sHomestrrot
                    call @usr_prep_home_axis
                endif
                iMotionmode = 0
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
            endif
            if i4xIndexClearanceMode eq 1
                if tool_z_level < tool_start_plane
                    Print 'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'
                    {nl,'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'}
                endif
                iMotionmode = 0
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'nPtool_z_level ' '}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'tool_z_level ' '}
            endif
            if i4xIndexClearanceMode eq 2
                iMotionmode = 0
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'nPtool_start_plane ' '}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'tool_start_plane ' '}
            endif
        endif
        if i4xIndexMode eq 1 ;New WorkOffset
            if i4xIndexClearanceMode eq 0
                if sHomestrrot ne ''
                    sHomestr = sHomestrrot
                    call @usr_prep_home_axis
                endif
                iMotionmode = 0
                iWorkoffset = iWorkoffset + (position-1)
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
            endif
            if i4xIndexClearanceMode eq 1
                if tool_z_level < tool_start_plane
                    Print 'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'
                    {nl,'WARNING!! Tool Z Level is below Tool Start Plane in CoordSys'}
                endif
                iMotionmode = 0
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'nPtool_z_level ' '}
                iWorkoffset = iWorkoffset + (position-1)
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'tool_z_level ' '}
            endif
            if i4xIndexClearanceMode eq 2
                iMotionmode = 0
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'nPtool_start_plane ' '}
                iWorkoffset = iWorkoffset + (position-1)
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
                {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],'Z'tool_start_plane ' '}
            endif
        endif
    endif
    if i4xIndexMode eq 2 ;Trig Macro
        if sHomestrrot ne ''
            sHomestr = sHomestrrot
            call @usr_prep_home_axis
        endif
        call @usr_trig_macro_call
        iMotionmode = 0
        iWorkoffset = 112
        {nb,['G'iMotionmode:mcode_f ' '],['G'iMplane' '],[cWo,iWorkoffset' '],['G'iAbsincmode ' '],[cR1,nR1pos ' ']}
    endif
endp

@move_4x ; !@#$%
    ; Handle GPP direct call to Rapid Move (G00)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @rapid_move, @move_5x, @move_4x, @move4x_polar, @move4x_cartesian
    if change(xpos)
        xpos = 0
    endif
    call @usr_rapid
endp

@line_4x ; !@#$%
    ; Handle GPP direct call to Line Movement (G01)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @line, @line_5x, @line_4x, @line4x_polar, @line4x_cartesian
    call @usr_line
endp
@chng_tool_cnext
endp
@rotary_info
endp
@tmatrix
endp
@move_5x ; !@#$%
    ; Handle GPP direct call to Rapid Move (G00)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @rapid_move, @move_5x, @move_4x, @move4x_polar, @move4x_cartesian
    call @usr_rapid
endp
@line_5x ; !@#$%
    ; Handle GPP direct call to Line Movement (G01)
    ; We not use this procedure to output code
    ; We create our own procedure for this so that we may...
    ;   Sync with @line, @line_5x, @line_4x, @line4x_polar, @line4x_cartesian
    call @usr_line
endp
@tool_path_info
endp
@transform_info
endp
@usr_trig_macro_call
    ; Handle SubProgram call to Trig_Macro
    {nb, 'G65P777 X'shift_x ' Y'shift_y ' Z'shift_z ' C'home_number:'5.3' ' A'bpos:'5.3'  ' I0 J0 K0 '}
    ;{nl,'G65P777 X'shift_x ' Y'shift_y ' Z'shift_z ' C'home_number '. A'nT1pos:'5.3' ' B'bpos:'5.3'  ' I0 J0 K0'}
endp
@usr_trig_macro_output
    ; Handle Trig_Macro output (Subprogram)
    {nl}
    {nl, 'O777'}
    ;Copies Work Offset(i.e. G54) to G112 to use for Calculations
    {nb,'G103 P1'}
    {nb,'#7041= [#[5201 + 20 * #3] + #24]'} ; G112 x
    {nb,'M01'}
    {nb,'#7042= [#[5202 + 20 * #3]+ #25]'} ; G112 y
    {nb,'M01'}
    {nb,'#7043= [#[5203 + 20 * #3] + #26]'} ; G112 z
    {nb,'M01'}
    {nb,'#7044= [#[5204 + 20 * #3]]'} ; G112 A
    {nb,'M01'}
    {nb,'#7045= [#[5205 + 20 * #3]]'} ; G112 B
    {nb,'M01'} ;Stop added For HS-1RP to not read ahead
    ;Variables 7xxx are G1xx additional work offsets. Puts work offsets in a variable
    ;#7001 through #7005 = G110 X, Y, Z, A, B   (this will be the A axis Zero) X=#7001 Z=#7003
    ;#7021 through #7025 = G111 X, Y, Z, A, B   (this will be the B axis Zero) X=#7021 Z=#7022
    ;x1 = #7021
    ;y  = #7022
    ;Y2 = #7002  PICKED UP CENTER OF Y-AXIS  G110#
    ;z  = #7003  PICKED UP CENTER OF Z-AXIS  G110#
    ;Delta Changes In Y & Z- Leg of triangle used to calculate new Y & Z
    {nb,'#141= [#7042 - #7002]'} ; delta y
    {nb,'M01'}
    {nb,'#142= [#7043 - #7003]'} ; delta z
    {nb,'M01'}
    ;Trig. Formula on how to calculate offcenter parts when they rotate around the 4th axis
    ;z = z*cos(dev_angle) - y*sin(dev_angle)
    ;y = z*sin(dev_angle)  + y*cos(dev_angle)
    ;Actual Trig. Formula to Calulate the change in Z & Y in the machine
    {nb,'#148 = [[#142*COS[-#1]] - [#141*SIN[-#1]]](NEW Y B)'}  ; z
    {nb,'M01'}
    {nb,'#149 = [[#142*SIN[-#1]] + [#141*COS[-#1]]](NEW Z B)'}  ; y
    {nb,'M01'}
    {nb}
    ;New Calculated Home Position- Uses shifts from SolidCAM, Centers of machine, and calculated change in Z & Y
    {nb,'#7041 = #7041 + #4'} ; X + user shift  = new X in g112
    {nb,'M01'}
    {nb,'#7042 = #7002 + #149 + #5'} ; center Y2 + new Y calculated point + user shift  = new Y in g112
    {nb,'M01'}
    {nb,'#7043 = #7003 + #148 + #6'} ; center z  + new z calculated point + user shift  = new z in g112
    {nb,'M01'}
    {nb,'G103'}
    ;{nb,'G112'}
    ;{nb,' G0 A#1'}
    ;Used to end subprogram
    {nb,'M99'}
    {nl}
endp
@home_data
    local integer var2
    local string  var1
    if position ne 1
        {nl,'(+++++++++++++++++)' }
        call @home_number
        {nl, '(' cWo,iWorkoffset') '}
        if change(iWorkoffset); !@#$% Force !change for variable
            change(iWorkoffset) = false
        endif
        call @usr_r1pos_calc
        skipline = false
        {'(B' nr1pos ') '}
        if part_home_number <= 6
            var1 = 'G0G90G10L2P'
            var2 = part_home_number
        else
            var1 = 'G0G90G10L20P'
            var2 = part_home_number - 6
        endif
        {nl,var1,var2'X',shift_x_after_rot:'5.3',' ' }
        {nl,var1,var2'Y',shift_y_after_rot:'5.3',' ' }
        {nl,var1,var2'Z',shift_z_after_rot:'5.3',' ' }
        {nl,var1,var2'B0. '}
        {nl}
    else
        {nl,'(+++++++++++++++++)' }
        {nl,'(SET WORK PAGE TO 0.0) ' }
        {nl,'#5201=0.0' }
        {nl,'#5203=0.0' }
        {nl,'#5202=0.0' }
        {nl,'(+++++++++++++++++)' }
    endif
    nr1pos = 9999
endp
